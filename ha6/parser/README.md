Парсер для языка L на основе парсер комбинаторов [csharp-monad](https://github.com/louthy/csharp-monad) для языка C#

Сразу скажем, что графмматика неоднозначна, поэтому будем считать, что в теле ифа и цикла может быть не более одной команды. В противном
невозможно понять где они заканчиваются. Эта проблема решается введением скобок, но мы не стали этого делать.

Для того чтобы открыть солюшн потребуется `Windows` и `Visual Studio`. (у меня стоит VS15, вероятно, должно открываться и в старых версиях).

HOWTO:
В файле `Example/exmaple.txt` лежит программа, которую по умолчанию нужно распарсить. В результате сгенерятся 3 файла - 
* `pretty_res.txt` - результат работы парсинга и претти принтера.
* `expr_opt_pretty_res.txt` - красиво напечатанная программа после оптимизаций выражений.
* `all_opts_pretty_res.txt` - красиво напечатанная программа после оптимизаций выражений и операторов (подробнее об этом ниже).

О тестах. Рядом с проектом `parser` лежит проект `Test`. Там находится множество юнит-тестов как на оптимизатор, так и на сам парсер.
Чтобы получить представление о том как всё работает, может быть полезным посмотреть туда.

Об оптимизациях.
* Простые случаи описанные в задании: прибавление нуля, умножение на ноль, логические операции с нулем и не нулем.
* Вычисление (упрощение) арифметических и логических выражений, если все операнды числа.
* Вычисление (упрощение) арифметических и логических выражений, с учетом контекста (известных значений переменных, которые были присвоены ранее).
* Упрощение операторов, вида:
    * `skip;statement; -> statement`
    * `if (true) then st1 else st2 -> st1`
    * `if (false) then st1 else st2 -> st2`
    * `while false do st -> skip`
* Упрощение операторов `if-then-else, while-do` с использованием информации из контекста. (while упрощается, только если выводимо false)

Сейчас в качестве примера предлагается программа
```
skip;
skip;
read x;
read y;
x := 10;
if (x < 10) then
	j := 10
else
	if (x > 12) then
		write 12
	else
		write (12 * 2);
x := 10;
y := (u * 0);
p := (u + 0);
v := (u || 1);
v := (1 || u);
z := (0 && u);
k := (0 + d);
while (x < 20) do
	x := (x + 1);
x := 20;
while (x < 20) do
	x := (x + 1);
if ((1 < 2) || (3 > 2)) then
	write x
else
	write y;
skip;
skip;
z := (((2 + 4) * 4) + (17 - 3));
while (0 + 9) do
	if (x > 20) then
		skip
	else
		while (x < 23) do
			x := (y + 1);
skip;
skip
```

Которая после оптимизаций приводится к виду:
```
read x;
read y;
x := 10;
write 24;
x := 10;
y := 0;
p := u;
v := 1;
v := 1;
z := 0;
k := d;
while (x < 20) do
	x := (x + 1);
x := 20;
write 20;
z := 38;
while 9 do
	if (x > 20) then
		skip
	else
		while (x < 23) do
			x := (y + 1);
skip
```
Заметим, что оптимизации выражений и операций зависят одна от другой, поэтому иногда нужно повторить несколько раз их выполнение. 
Сейчас они повторяются 10 раз. Для программы из примера достаточно и двух. 
